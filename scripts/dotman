#!/usr/bin/sh
print_row() {
    for i in {1..80}; do
        printf "-";
    done
    printf "\n";
}

tilde_path() {
    echo "$1" | sed s/${HOME//\//\\\/}/\~/
}

### Symlinks ###
DOTFILES_BACKUP_PATH="$HOME/.dotfiles-backup"
BACKUP_DIR="$DOTFILES_BACKUP_PATH/$(date +%s)"
BACKUP_DIR_TILDE=$(tilde_path $BACKUP_DIR)
DOTFILES_PATH="$HOME/.dotfiles"
DOTFILES_SCRIPT_PATH="scripts"
DOTFILES_USR_BIN="/usr/bin"

printf "Updating dotfiles symlinks to $(tilde_path $DOTFILES_PATH)\n\n"
ROOT_FILE_NAMES=($(ls -a $DOTFILES_PATH | grep -E "^\.|$DOTFILES_SCRIPT_PATH" | \
    grep -Ev "[\.]+$|\.git$" | xargs -n1 printf "%s "));

for ROOT_FILENAME in ${ROOT_FILE_NAMES[@]}; do
    TARGET_PATH="$DOTFILES_PATH/$ROOT_FILENAME";
    FILENAMES=("$ROOT_FILENAME")
    if [ -d $TARGET_PATH ]; then
        FILENAMES=($(ls $TARGET_PATH | xargs -n1 printf "$ROOT_FILENAME/%s "));
    fi
    for FILENAME in ${FILENAMES[@]}; do
        SRC_PATH="$HOME/$FILENAME"
        if [ "$ROOT_FILENAME" == "$DOTFILES_SCRIPT_PATH" ]; then
            SRC_PATH="$DOTFILES_USR_BIN/$(basename $FILENAME)"
        fi
        SRC_PATH_TILDE=$(tilde_path $SRC_PATH);
        TARGET_PATH="$DOTFILES_PATH/$FILENAME"
        TARGET_PATH_TILDE=$(tilde_path $TARGET_PATH);
        if [ -s $SRC_PATH ] || [ -L $SRC_PATH ]; then
            LINK_PATH=$(readlink $SRC_PATH)
            if [ "$LINK_PATH" == "$TARGET_PATH" ]; then
                echo "[SAME]    $SRC_PATH_TILDE -> $TARGET_PATH_TILDE";
                print_row
                continue;
            else
                if [ -d "$DOTFILES_PATH/$ROOT_FILENAME" ]; then
                    mkdir -p "$BACKUP_DIR/$ROOT_FILENAME";
                fi
                MV="mv $SRC_PATH $BACKUP_DIR/$FILENAME &>/dev/null";
                eval "$MV || sudo $MV";
                printf "[BACKUP]  $SRC_PATH_TILDE -> $TARGET_PATH_TILDE\n"
                printf "          (moved to $BACKUP_DIR_TILDE/$FILENAME)\n";
            fi
            printf "[UPDATED] ";
        else
            printf "[NEW]    ";
        fi
        LN="ln -s $TARGET_PATH $SRC_PATH &>/dev/null"
        eval "$LN || sudo $LN";
        printf "$SRC_PATH_TILDE -> $TARGET_PATH_TILDE\n"
        print_row
    done
done

# ssh config file can't be accessed by ssh if it is a symbolic link.
#
# The way that I found to solve this for now, is renaming the original config
# file to .ssh_src and copying its content to the config file, which is not a
# sym link and now can be used by ssh. I am also setting the config files
# permission to avoid permission errors.
#
mv "$HOME/.ssh/config" "$HOME/.ssh/config_src" && \
    cp "$HOME/.ssh/config_src" "$HOME/.ssh/config" &&\
    chmod 644 "$HOME/.ssh/config" &>/dev/null

printf "Symlinks to dotfiles updated!\n";
